---
layout: single
title: webRCT
categories: PROJECT
tag: []
---

1. # webRCT
   내가 방을 만들든, 내가 다른 방에 참여하든 자신의 브라우저는 자신의 방에서 Publisher.   
   방장 입장에서 나는 subscribe.

1. # 메서드
   ```javascript

      var sfutest = null;

      Janus.init({debug: "all", callback: function() { //야누스 서버 초기화
		
			janus = new Janus( //야누스 객체 생성
         {
            server: server,
            success: function() {
               janus.attach( //야누스 서버에 접속
                  {
                     plugin: "janus.plugin.videoroom",
                     opaqueId: opaqueId,
                     success: function(pluginHandle) { //접속 성공이면 success 반환
                        sfutest = pluginHandle; //sfutest가 webRTC 연결 객체
                        ...
                     }  ,
                     webrtcState: function(on) {
                        ...
                     }, 
                     onmessage: function(msg, jsep) {
                        ...
                     },  
                     onlocalstream: function(stream) {
                        ...
                     },
                     onremotestream: function(stream) {
                        ...
                     },
                     oncleanup: function() {
                        ...
                     }
                  });
               },
            })
         }
      })
   ```
   webrtcState,onmessage,onlocalstream,onremotestream,oncleanup

   다음과 같은 메소드들은 야누스 서버로부터 이벤트가 발생했을 경우 받게 되는 함수들입니다.   

   ```yml
      success -> 
      registerUsername()   
      {   
         display : "user"
         ptype : "publisher"
         request : "join"
         room : 88556
      }

      # 기존 참가자가 없는 경우
      -> onmessage : msg
      {
         description : "test"
         id : 7475349030294197
         private_id : 2799667236
         publishers : Array(0)
         length : 0
         [[Prototype]] : Array(0)
         room : 88556
         videoroom : "joined"
         [[Prototype]] : Object
      }

      # 참가자가 있는 경우
      -> onmessage : msg
      {
         description : "test"
         id : 7475349030294197 # 내 id
         private_id : 2799667236
         publishers : Array(1)
            0 : {id: 5437609289359478 , display: 'Xhhf', audio_codec: 'opus', video_codec: 'vp8', streams: Array(2), …}  
            # 5437609289359478 기존 참가자 id
               length : 1  
            [[Prototype]] : Array(0)
         room : 88556
         videoroom : "joined"
         [[Prototype]] : Object
      }
      -> newRemoteFeed() : 새로운 유저 들어왔을 때 
      -> onlocalstream : stream
      {
         active : true
         id : "775e7f12-d43b-4c16-9caf-91bee25f8e1c"
         onactive : null
         onaddtrack : null
         oninactive : null
         onremovetrack : null
      }
      -> onmessage : msg   
      {
         audio_codec : "opus"
         configured : "ok"
         room : 88556
         streams : Array(2)
            0 : {type: 'audio', mindex: 0, mid: '0', codec: 'opus', opus-fec: true}
            1 : {type: 'video', mindex: 1, mid: '1', codec: 'vp8'}
         length : 2
         [[Prototype]] : Array(0)
         video_codec : "vp8"
         videoroom : "event"
      }
   ```
   위에 함수 중에서 가장 주의 깊게 봐야할 함수는 onmessage함수입니다. onmessage함수는 데이터 채널(DataChannel)을 통해 수신된 메시지를 처리하는 이벤트 핸들러입니다. sfutest.send 이후에 호출되는 콜백 함수입니다. WebRTC는 음성, 비디오뿐만 아니라 데이터를 실시간으로 전송할 수 있는 기능을 제공하며, 데이터 채널은 주로 텍스트, 파일, 바이너리 데이터 전송에 사용됩니다. 전송하는 주체, 전송받는 주체에 이벤트가 발생하면 호출되는 콜백함수입니다. 따라서 다른 함수들에 비해 사용 빈도가 높습니다. 누군가 회의에 참석하거나 나가는 경우, 다른 이벤트가 발생하는 경우에 실행되는 함수가 onmessage입니다.   

1. # Publisher 와 Subscriber
   내가 송출하는 경우 나는 Publisher   
   내가 수신하는 경우 나는 Subscriber   

   1. ## 단방향(교육, 아프리카TV)   
      방장 : Publisher   
      참가자 : Subscriber   

   1. ## 양방향(회의)   
      방장 : Publisher 이면서 Subscriber   
      참가자 : Publisher 이면서 Subscriber

1. # Publisher와 Subscriber를 결정짓는 핵심 소스

   offer생성
   ```javascript
      - publishOwnFeed() -

      sfutest.createOffer( //
		{
			/*
			//오디오 비디오 수신 : audioRecv, videoRecv
			//오디오 비디오 송신 : audioSend, videoSend
			WebRTC 피어 단계 - 브라우저 간의 WebRTC 설정 단계, 현재 subscribe 구독자 브라우저기 때문에 
			수신은 true, 송신은 false
			*/
			media: { audioRecv: true, videoRecv: true, audioSend: false, videoSend: false },	// subscriber
         media: { audioRecv: false, videoRecv: false, audioSend: true, videoSend: true },	// publisher
			
			simulcast: doSimulcast,
			simulcast2: doSimulcast2,
			success: function(jsep) {
				Janus.debug("Got publisher SDP!", jsep);
				/*
				클라이언트가 야누스 서버 플러그인에 대한 오디오, 비디오 설정을 보낸다

				VideoRoom 플러그인의 주요 요청 명령어는 다음과 같습니다:

				join: 방에 참가.
				publish: 자신의 스트림을 방에 송출.
				subscribe: 특정 스트림을 구독.
				configure: 미디어 트랙 구성 변경.
				leave: 방을 떠남.
            */
				
            //publisher로 서버에 offer전달
				var publish = { request: "configure", audio: true, video: true };
				sfutest.send({ message: publish });
				
            //subscriber로 서버에 offer전달
				var subscribe = { request: "subscribe", streams: [{ feed: parseInt(방번호) }] };
				//streams: [{ feed: 1234, mid: "video" }] 특정 미디어 video만 수신
				sfutest.send({ message: subscribe });
			}
      }
   ```

   방 생성   
   ```javascript
      - registerUsername() -

      var createRoom = {
         request : "create",
         room : myroom,
         permanent : false,
         record: false,
         publishers: 6,
         bitrate : 128000,
         fir_freq : 10,
         //ptype: "publisher",
         ptype: "publisher",
         description: "test",
         is_private: false
      }

      sfutest.send({ message: createRoom, success:function(result){ ... }})
   ```

   Publisher로 방 참가
   ```javascript
      - registerUsername() -

      var joinRequest = {
      request: "join",
      room: 1234, // 방 ID
      ptype: "publisher", // Publisher로 참가
      display: "Publisher Name" // 표시 이름
      };
      sfutest.send({ message: joinRequest });
   ```

   Subscriber로 바로 방 참가
   ```javascript
      - registerUsername() -

      var joinRequest = {
      request: "join",
      room: 1234, // 동일한 방 ID
      ptype: "subscriber", // Subscriber로 참가
      };
      sfutest.send({ message: joinRequest });
   ```

1. # 메소드 

   1. ## newRemoteFeed() : 새로운 유저가 들어왔을 때   

      1. 단뱡향 : A방에 B가 입장   
      captin이란 방장이 이미 A방에 있는 경우 : B란 참가자가 들어왔다 -> 이때, B의 입장에 새로운 유저란 captin 방장이 된다.   

      1. 양방향 : A방에 B가 입장   
      captin입장에서 새로운 유저란 B.   
      B입장에서 새로운 유저란 captin   

   1. ## publishOwnFeed() : 화면 설정   
      1.WebRTC와 브라우저간의 수신, 송신 설정   
      2.야누스 서버 플로그인과 클라이언트의 수신, 송신 설정   
      => 위에 2개가 일치해야 한다   

   1. ## registerUsername() : 방을 만들거나 조인   
      사용자를 webRCT에 등록   
      방을 만들 수 있고, 다른 방을 참관할 수 있는 subscriber설정   

1. # 이슈

   1. ## Whoops! Lost connection to http://localhost/chat
   WebScoketConfig에서 Configuration 어노테이션을 Configuable로 사용
      
   ```yml
      configurable 어노테이션과 controller 어노테이션을 같이 사용할 수 있나
      ChatGPT의 말:
      ChatGPT
      @Configurable과 @Controller는 Spring에서 각기 다른 목적을 가진 어노테이션입니다. 이 두 어노테이션을 같이 사용할 수는 있지만, 일반적으로는 함께 사용하는 것이 적합하지 않습니다. 이유는 두 어노테이션의 역할이 서로 다르기 때문입니다.

      @Configurable 어노테이션
      목적:
      Spring에서 관리되지 않는 객체(직접 생성된 객체)에 대해 의존성 주입(Dependency Injection)을 지원하기 위해 사용됩니다.
      주요 특징:
      AOP와 AspectJ를 통해 동작합니다.
      일반적으로 Spring 컨텍스트 외부에서 생성된 객체에 대해 사용됩니다.
      사용 예:
      java
      코드 복사
      @Configurable
      public class MyCustomObject {
         @Autowired
         private SomeService someService;
      }
      @Controller 어노테이션
      목적:
      Spring MVC에서 HTTP 요청을 처리하기 위한 컨트롤러를 정의합니다.
      주요 특징:
      Spring이 관리하는 Bean이며, 기본적으로 DI와 라이프사이클 관리를 Spring 컨테이너가 수행합니다.
      요청 매핑(@RequestMapping)과 함께 사용됩니다.
      사용 예:
      java
      코드 복사
      @Controller
      public class MyController {
         @GetMapping("/hello")
         public String sayHello() {
            return "hello";
         }
      }
      두 어노테이션을 함께 사용하는 경우
      가능하지만 비효율적
      @Configurable은 Spring이 관리하지 않는 객체에서 의존성 주입을 가능하게 하지만, @Controller는 Spring이 이미 관리하는 Bean입니다. 따라서 @Configurable의 주요 목적은 @Controller와 충돌하거나 불필요하게 됩니다.

      예제: 두 어노테이션을 함께 사용
      java
      코드 복사
      @Configurable
      @Controller
      public class MyController {
         @Autowired
         private SomeService someService;

         @GetMapping("/test")
         public String test() {
            someService.performService();
            return "test";
         }
      }
      이 경우, @Controller로 인해 Spring 컨테이너에서 관리되고 있기 때문에 @Configurable의 기능은 사실상 필요하지 않습니다.
      권장 사항
      @Configurable는 일반 객체에 사용:

      Spring 컨테이너 외부에서 생성되는 객체(예: new 키워드로 생성되는 객체)에서 의존성 주입이 필요할 때 사용합니다.
      @Controller는 Spring MVC 컨트롤러에만 사용:

      Spring이 관리하는 Bean으로 작동하며, DI와 요청 매핑을 지원합니다.
      대안:

      @Configurable가 필요한 객체는 컨트롤러가 아닌 별도의 클래스에서 사용하도록 설계하세요.
      예: Service 계층에서 @Configurable 객체를 생성하고 관리.
      결론
      @Configurable과 @Controller는 서로 다른 목적을 위해 설계되었습니다.
      같이 사용하는 것은 기술적으로 가능하지만, 적합하지 않습니다.
      컨트롤러는 Spring이 관리하는 Bean으로 충분히 동작하므로, @Configurable 없이도 의존성 주입과 관리가 가능합니다.
      추가적인 사용 사례나 필요에 따라 더 구체적인 설계 조언을 드릴 수 있으니 알려주세요!

      나의 말:
      WebSocketConfig 위에 Configurable을 사용해야 하나 Controller를 사용해야하나 어떤 어노테이션을 사용하나
      ChatGPT의 말:
      ChatGPT
      WebSocketConfig 클래스 위에 사용하는 어노테이션은 해당 클래스의 역할에 따라 다릅니다. WebSocketConfig는 일반적으로 WebSocket 및 STOMP 설정을 정의하는 설정 클래스로 사용됩니다. 따라서 @Configurable이나 @Controller가 아닌, @Configuration 어노테이션을 사용해야 합니다.

      왜 @Configuration을 사용해야 하는가?
      @Configuration:

      WebSocketConfig는 WebSocket 관련 설정을 담당하는 클래스입니다.
      설정 클래스를 Spring 컨테이너에 등록하려면 @Configuration을 사용해야 합니다.
      설정 클래스에서 Bean 등록이나 설정을 수행할 수 있습니다.
      예제:
      java
      코드 복사
      import org.springframework.context.annotation.Configuration;
      import org.springframework.messaging.simp.config.MessageBrokerRegistry;
      import org.springframework.web.socket.config.annotation.EnableWebSocketMessageBroker;
      import org.springframework.web.socket.config.annotation.StompEndpointRegistry;
      import org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurer;

      @Configuration
      @EnableWebSocketMessageBroker
      public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

         @Override
         public void configureMessageBroker(MessageBrokerRegistry config) {
            config.enableSimpleBroker("/topic"); // 브로커 경로
            config.setApplicationDestinationPrefixes("/app"); // 메시지 송신 경로
         }

         @Override
         public void registerStompEndpoints(StompEndpointRegistry registry) {
            registry.addEndpoint("/chat") // 클라이언트가 접속할 엔드포인트
                     .setAllowedOrigins("*") // CORS 설정
                     .withSockJS(); // SockJS 폴백 지원
         }
      }
      @Controller:

      @Controller는 HTTP 요청을 처리하는 Spring MVC 컨트롤러에서 사용됩니다.
      WebSocket 설정 클래스에는 적합하지 않습니다.
      WebSocketConfig와는 역할이 다릅니다.
      @Configurable:

      Spring 컨테이너 외부에서 생성된 객체에 의존성 주입을 지원하는 어노테이션입니다.
      WebSocketConfig는 Spring이 직접 관리하는 설정 클래스이므로 @Configurable이 필요하지 않습니다.
      정리
      WebSocket 설정 클래스에는 **@Configuration**을 사용하세요.
      추가로 WebSocket STOMP 브로커를 활성화하려면 **@EnableWebSocketMessageBroker**도 함께 사용해야 합니다.
      **@Controller**는 HTTP 요청을 처리하는 컨트롤러에만 사용합니다.
      **@Configurable**은 Spring 컨테이너 외부에서 생성된 객체에 한정해서 사용합니다.
   ```

   정상 연결 메시지   
   ```
      Opening Web Socket...
      Web Socket Opened...
      
      >>> CONNECT
      accept-version:1.1,1.0
      heart-beat:10000,10000

      <<< CONNECTED
      version:1.1
      heart-beat:0,0

      Connected to server: CONNECTED
      heart-beat:0,0
      version:1.1

      >>> SUBSCRIBE
      id:sub-0
      destination:/topic/messages
   ```
   1. ## 최신 sockjs와 stomp사용
   ```cs
      <script src="https://cdn.jsdelivr.net/npm/sockjs-client/dist/sockjs.min.js"></script>
      <script src="https://cdn.jsdelivr.net/npm/stompjs/lib/stomp.min.js"></script>
   ```

   1. ## connected to server undefined


   1. ## setAllowedOrigins 에러
   ```java
      registry.addEndpoint("/chat") // 클라이언트가 연결할 엔드포인트
            .setAllowedOrigins("*") // 모든 도메인 허용 (개발 환경에서만)
            .withSockJS(); // SockJS 지원

      => @CrossOrigin(origins = "*", methods = RequestMethod.GET)
   ```

   1. ## sendMessage()는 발생하는데 서버에서 받는 게 안된다.   
      __1)__   
      ```javascript
         - chat.jsp -

         stompClient.send('/app/sendMessage', {} , JSON.stringify({sender, contents}));
      ```   
      send주소에 `/app/sendMessage` 슬래쉬 확인 => `/app/sendMessage`와 `app/sendMessage`는 다른다   

      ```java
         - WebSocketConfig.java -

         registry.setApplicationDestinationPrefixes("/app");
      ```   
      서버의 setApplicationDestinationPrefixes와 일치 시킨다.   

      __2)__   
      클라이언트에서는 app를 적어주고  
      ```java
         - chat.jsp -
      
         stompClient.send('/app/sendMessage', {} ...
      ```
      서버의 컨트롤러에서 mapping값은 sendMessage만 적는다   
      ```java
         - ChatController.java -

          @MessageMapping("/sendMessage") 
          ...
      ```

      __3)__    
      `JSON.stringify({sender, contents})` 값이 DTO 와 일치하는지 확인
      ```java
         - ChatMessage.java -

         public class ChatMessage {
   
         private String sender;
         private String contents;
         ...
      ```