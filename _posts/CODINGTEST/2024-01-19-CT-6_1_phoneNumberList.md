---
layout: single
title: 6-1 전화번호 목록
categories: CODINGTEST
tag: []
---

1. # 문제 설명
   전화번호부에 적힌 전화번호 중, 한 번호가 다른 번호의 접두어인 경우가 있는지 확인하려 합니다.
   전화번호가 다음과 같을 경우, 구조대 전화번호는 영석이의 전화번호의 접두사입니다.

   구조대 : 119
   박준영 : 97 674 223
   지영석 : 11 9552 4421
   전화번호부에 적힌 전화번호를 담은 배열 phone_book 이 solution 함수의 매개변수로 주어질 때, 어떤 번호가 다른 번호의 접두어인 경우가 있으면 false를 그렇지 않으면 true를 return 하도록 solution 함수를 작성해주세요.

   제한 사항
   phone_book의 길이는 1 이상 1,000,000 이하입니다.
   각 전화번호의 길이는 1 이상 20 이하입니다.
   같은 전화번호가 중복해서 들어있지 않습니다.

   입출력 예제

   |              phone_book         | return |
   |:-------------------------------:|:------:|
   |["119", "97674223", "1195524421"]| false  |
   |      ["123","456","789"]        |  true  |
   | ["12","123","1235","567","88"]  | false  |
   
   입출력 예 설명

   입출력 예 #1
   앞에서 설명한 예와 같습니다.

   입출력 예 #2
   한 번호가 다른 번호의 접두사인 경우가 없으므로, 답은 true입니다.

   입출력 예 #3
   첫 번째 전화번호, “12”가 두 번째 전화번호 “123”의 접두사입니다. 따라서 답은 false입니다.   

1. # 풀이
    String클래스에 contains()메소드도 있는데 이것은 해당 문자열이 포함되어 있는지 여부를 판단하는 포함 관계를 파악하는 메소드이고, 접두어 같은 경우는 startsWith()메소드가 있습니다. 해당 문자열로 시작하게되면 true를 반환합니다.   
    문자열이 같은 경우 접두어로 포함되지 않습니다. 그런데 startsWith()는 문자열이 같은 경우도 true를 리턴하기 때문에 startsWith()를 사용하기 전에 조건문으로 continute를 해야합니다.   
    문자열이 같은지 판단은 equals메소드를 이용합니다.
   
    ```java
       public boolean solution(String[] phoneBook) {
        boolean answer = true;
    
        Arrays.sort(phoneBook);
        
        for(int i=0 ; i<book.length-1 ; i++){
            if(book[i+1].startsWith(phoneBook[i])) return false;
        }
         
        return true;
    }
   ```   
    먼저 해당 배열을 정렬합니다. 이 문제에서 핵심은 sort로 먼저 정렬은 해야 한다는 것인데, 숫자로 이루어진 문자열 역시 오름차순으로 정렬이 가능합니다.   

    예)"24556", "24789", "31115", "199987"   
    처럼 숫자로 이루어진 문자열이 있는 경우   
    199987   
    24556   
    24789   
    31115   
    와 같이 사전순 대로 정렬이 됩니다.   

    접두어라면 앞에 있는 작은 수가 뒤에 있는 큰 수에 포함이 될 수밖에 없습니다. 가장 생각하기 쉬운 방법은 이중반복문을 이용하는 것인데, sort의 이 성질을 이용하면 한 개의 반복문으로도 풀 수가 있습니다.   