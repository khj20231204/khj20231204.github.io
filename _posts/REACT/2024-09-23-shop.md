---
layout: single
title: shop
categories: REACT
tab: 
---

1. # data.js import와 export
   data.js파일도 import함   
   ```javascript
      let data = [
         {
         id : 0,
         title : "White and Black",
         content : "Born in France",
         price : 120000
         },
      
         {
         id : 1,
         title : "Red Knit",
         content : "Born in Seoul",
         price : 110000
         },
      
         {
         id : 2,
         title : "Grey Yordan",
         content : "Born in the States",
         price : 130000
         }
      ] 

      export default data;
   ```   
   하단에 export default data;를 함

   사용하는 곳에서는 import를 해야 됨   
   ```javascript
      import data from './data'
   ```
   import경로는 점슬래쉬(./)로 시작합니다.   

1. # 컴포넌트로 useState전달
   App.js에서 Card란 컴포넌트를 사용하는데 App.js에 shoesData란 useState가 있는 경우   

   App.js
   ```javascript
      function App() {

         const [shoesData] = useState(data);

         return(
            <Row>
               {shoesData.map((e,i) => {
                  return(
                     <Card shoesData={shoesData[i]} key={i} num={i}></Card>
                  )
               })}
            </Row>
         )
      }
   ```   
   Card란 컴포넌트에 shoesData란 변수명으로 {shoesData}란 useState 값을 넘겨 줍니다.   

   Card.js
   ```javascript
      function Card(props){
         return (
            <Col>
               <img src={"/img2/shoes"+ props.num +".jpg"} width="50%"></img>
               <h4>{props.shoesData.title}</h4>
               <p>{props.shoesData.price}원</p>
               <p>상품 설명</p>
            </Col>
         )
      }

      export default Card;
   ```   
   Card(props) props란 매개변수를 전달받게 되는데 props는 객체기 때문에 내부에 다양한 이름과 값이 있습니다. 다양한 이름 중 shoesData를 사용.

1. # router
   리액트를 사용하기 전에는 새로운 페이지로 넘어가게 되면 새로운 html페이지를 보여주었지만,   
   리액트를 사용하게 되면 페이지 이동없이 새로운 컴포넌트를 보여주게 됩니다.

1. # styled-components

   설치
   ```javascript   
       npm install styled-components
   ```

   사용
   ```javascript
      import styled from 'styled-components' //import

      //선언
      let YellowBtn = styled.button`   
         background : yellow;
         color : balck;
         padding : 10px;
      `

      let BlackDiv = styled.div`
         background : gray;
         padding : 10px;
         width : 100%
      `

      //활용
      <YellowBtn>yellowBtn</YellowBtn>
      <BlackDiv></BlackDiv>
   ```   
   styled.요소 styled이후에 점을 찍은 후 스타일을 지정하고 싶은 요소를 써주면 됩니다. 변수에 할당하면 변수 이름이 하나의 컴포넌트가 됩니다.   

   styled-components의 장점   
   장점1. CSS 파일 오픈할 필요없이 JS 파일에서 바로 스타일넣을 수 있습니다.
   장점2. 여기 적은 스타일이 다른 JS 파일로 오염되지 않습니다. 원래 그냥 CSS파일은 오염됩니다.
   장점3. 페이지 로딩시간 단축됩니다.

   useState로 활용해서 적용
   ```javascript
      let YellowBtn = styled.button`
         background : ${props => props.bg}
      `

      <YellowBtn bg="blue">버튼</YellowBtn>
   ```

   조건식을 줄 수도 있습니다.
   ```javascript
      let YellowBtn = styled.button`
      background : ${props => props.bg};
      color : ${ props => props.bg == 'blue' ? 'white' : 'black'};
      padding : 10px;
   `
   ```

   기존 스타일을 복사해서 커스터마이징도 됩니다.   
   ```javascript
      let CopyYellowBtn = styled.button(YellowBtn)`
         font-style : bold;
      `
   ```

1. # css 적용 범위 제한
   App.module.css => 컴포넌트.module.css로 css이름 형식을 지어주면 해당 컴포넌트에서만 css파일이 적용됩니다.   

1. # useEffect
   useEffect 실행시 2번 실행되는 경우 제거   

   index.js파일에서 <React.StrictMode> 삭제   
   ```javascript
      const root = ReactDOM.createRoot(document.getElementById('root'));
         root.render(
         <React.StrictMode> /* 삭제 */
            <BrowserRouter>
            {/* <App2 /> */}
            <App />
            </BrowserRouter>
         </React.StrictMode>
         );
   ```   

   useEffect 안에 있는 코드는 __html 렌더링 후__ 에 동작합니다.   
   ```javascript
      useEffect(() => {
         /*
         sideEffect : 함수의 핵심기능과 상관없는 부가기능
         어려운 연산(≒ 시간 걸리는 연산) 
         서버에서 데이터 가져오는 작업
         타이머 장작하는 거
         */
      })
   ```   

   __clean up function__   
   ```javascript
      useEffect(() => {
         return () =>{
            /* 코드 작성 */
         }
      },[])
   ```
   useEffect안에 return을 사용하면 __useEffect가 실행되기 전 먼저 실행__.   
   unmount시 또 한번 실행   

   *unmout : 다른 페이지로 넘어갔을 때   

   ```javascript
      useEffect(() => {

         let timeF = setTimeout(() => {
              console.log(1) ;
         }, 2000)

         return (() => {
            /* 타이머 함수를 정리할 때 사용 */
            CleanTimeout(timeF); 
         })
      })
   ```

   __정리__   
   1.재렌더링마다 코드를 실행하고 싶은 경우 : useEffect(() => {})   
   2.mount 딱 한번만 코드를 실행하고 싶다 : useEffect(() => {}, [])   
   3.useEffect보다 먼저 실행, unmout시 1회 코드 실행 : return함수 사용

1. # ajax

   get으로 데이터를 가져옵니다.   

   ```javascript
      <button onClick={() => {
         axios.get('https://codingapple1.github.io/shop/data2.json')
         .then((e) => {
              let copyShoes = [...shoesData, ...e.data]; //shoesData객체와 e.data객체를 합치기
              setShoesData(copyShoes);
         })
         .catch(() => {
            alert("ajax error");
         })
      }}>상품 더 보기</button>
   ```
   axios의 결과를 e 매개변수로 받을 때 기존 data 이 외에 여러가지 다양한 정보를 가져오는데 e.data로 접근하면 json형태의 데이터만 가져옵니다.   

   ...은 shoesData객체와 e.data를 벗긴다. 

   post로 데이터를 전송합니다.

   ```javascript
      axios.post('URL',{name:'kim'})
   ```   

   __원래 서버와 문자자료만 주고받을 수 있음__   
   object/array 이런거 못주고받습니다.   
   array 자료를 받으려면 object/array 자료에 따옴표를 쳐놓으면 됩니다.   

   ```json
      "{"name" : "kim"}"
   ```
   이걸 JSON 이라고 합니다. JSON은 문자 취급을 받기 때문에 서버와 자유롭게 주고받을 수 있습니다. 그래서 실제로 결과.data 출력해보면 따옴표쳐진 JSON이 나와야하는데 axios 라이브러리는 JSON -> object/array 변환작업을 자동으로 해줘서 출력해보면 object/array가 나옵니다. 

   ```javascript
      fetch('URL').then(결과 => 결과.json()).then((결과) => { console.log(결과) } )
   ```   
   쌩자바스크립트 문법인 fetch() 를 이용해도 GET/POST 요청이 가능한데 그건 JSON -> object/array 이렇게 자동으로 안바꿔줘서 직접 바꾸는 작업이 필요합니다.  