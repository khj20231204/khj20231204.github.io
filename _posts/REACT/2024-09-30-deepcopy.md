---
layout: single
title: 깊은 복사를 하는 배열 함수
categories: REACT
tab: [react]
---

1. # 깊은 복사를 하는 배열 함수
   concat, filter, map, slice, 스프레드(전개) 연산자가 있습니다. 이 5가지 함수는 결과를 다른 변수에 대입합니다.    

1. # 스프레드 연산자
   ```javascript
      const a = [1,2,3];
      const b = [...a];

      a.push(4); //b의 데이터 변경

      console.log('a:'+ a , 'b:'+b); //a:1,2,3,4  b:1,2,3
   ```   
   a를 변경해도 b는 변함이 없습니다.   

1. # concat :  추가하기
   ```javascript
      const a2 = [1,2,3];
      const b2 = a2.concat(4,5);

      console.log(`a2:${a2} , b2:${b2}`); //a2:1,2,3 , b2:1,2,3,4,5
   ```
   a2에 concat을 해도 a2의 값은 변함이 없고 이것을 할당한 b2에만 결합된 값이 입력됩니다.   
   concat은 a2 원본의 값을 변화시키지 않습니다.   

   ```javascript
      const a2 = [1,2,3];
      a2.push(4,5);

      console.log(`a2:${a2}`); //a2:1,2,3,4,5
   ```
   push는 a2 원본의 값을 변화시킵니다.   

1. # filter : 걸러내기 - 삭제할 때 사용
   bool을 return 받습니다.   

   ```javascript
      const a3 = [1,2,3];
      const b3 = a3.filter((n) => {
         return n != 1;
      })

      console.log(`a3:${a3} , b3:${b3}`) //a3:1,2,3 , b3:2,3
   ```  
   filter는 false를 걸러냅니다. 

1. # 배열 값 변경
   a = [1,2,3] 일 때 [0,1,2,3,4]를 만드는 방법   
   ```javascript
      const a = [1,2,3];
      const b = [0, ...a, 4];
      console.log(b);  // [0, 1, 2, 3, 4]
   ```   

   a = [1,2,3] 일 때 [0,1,3,5] 를 만드는 방법   
   ```javascript
      const a = [1,2,3];
      
      const b = a.filter((n) => {
         return n != 2;
      })

      const c = [0, ...b, 5];
      
      console.log(c);  //[0, 1, 3, 5]
   ```

1. # slice : 잘라내기
   slice(idx1, idx2);   
   slice 안에 들어가는 값은 __인덱스__ 번호입니다. idx1 __부터__ idx2 __미만__ 까지 입니다.   

   ```javascript
      const a = [1,2,3];
      const b = a.slice(1,3);
      console.log(b); // [2, 3]
   ```

   ```javascript
      const a = [1,2,3];

      const b = a.slice(0,2);  //[1,2]
      const c = [a.slice(0,2)];  //[[1,2]]
      const d = [...a.slice(0,2)]  //[1,2]

      console.log(`b[0]:${b[0]} , c[0]:${c[0]} , d[0]:${d[0]}`); 
      //b[0]:1 , c[0]:1,2 , d[0]:1
   ```

1. # map : 반복하기

   map를 사용하는 이유   

   ```javascript
      //jsx 안에서 for문 사용 불가
      for(var i=0 ; i<a.length ; i++){
         console.log(a[i])
      }

      //a.forEach(callback함수), forEach는 리턴을 하지 않음
      a.forEach((n) => {console.log(n)}) //함수 실행
      a.forEach((n) => console.log(n)) //자동 리턴문, forEacn는 리턴을 하지 않아서 값을 뿌리고 끝난다

      let b_ = a.forEach(() => {}); //리턴을 하지 않는다
      console.log(`b_:${b_}`); //b_:undefined

      //값을 받아서 복사하기 위해서는 리턴을 받아야한다.

      const b = a.map(()=> {});  //리턴을 한다
      console.log(`b:${b}`);  // , b:,, , 아직 값을 할당하기 전 상태
   ```

   ```javascript
      b = a.map((n) => n); 
      b = [...a];
      //2개 결과는 같음
   ```
   b = a.map((n) => n); 와 b = [...a] 는  결과는 같지만 map는 값을 가공할 수 있다   



   





   